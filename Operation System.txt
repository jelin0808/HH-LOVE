01010101是电信号的高低电阻，这就是为什么计算机只认010101的原因


CPU包含：控制单元，存储单元，运算单元ALU

逻辑核与物理核  

CPU的多级缓存有大小区别

L1离CPU最近，速度比较，CPU内核寄存器>L1>L2>L3>内存

每一个CPU独有一个寄存器，不能被别的CPU访问到，只能被自己的CPU访问到

L1和L2是每个CPU内核独享，L3是每个CPU内核共享，但是也是每个CPU独享，其它CPU是访问不到缓存的

最小的存储单位（单元），缓存行，64字节

L3有多少缓存行呢，比方说L3 = 8M，那就是8*1024*1024/64个缓存行

先去L1找，没有再去L2，没有再去L3，没有，就去内存那里面找，如果在内存里面找到了，不会直接读到CPU内核寄存器里面，而是先放到L3缓存起来，在拷贝一份到L2，然后在拷贝到L1，然后才是内核寄存器，当然，最先填满的是L1，所以如果被淘汰了，没关系，L1淘汰了再去L2嘛，还是那个流程，然后再拷贝到L1，当然，如果数据大小超过64byte，那就给多一点缓存行，256byte就给4个缓存行呗（当然一般这么大的比较少）


空间局部性原则：
在寄存器拿到数据X=0时，并不仅仅只是把X=0拿到L3、2、1和寄存器中，而是会把X=0临近的（相邻的）空间一次性拿到缓存空间里面来（有一个点需要注意一下，缓存行缓存行，估计是行临近的才去拿，列不算临近，比方说二维数组 ）


时间局部性原则：
大部分指令还是按照从上往下去执行的
一个数据在被访问到的时候，访问结束之后不会马上干掉，因为这个数据在被访问到之后，后面可能还是会被访问到（当然时间不能太长，太长还是会被干掉）



内核态和用户态（内核空间，用户空间）
操作系统在内核空间运行
其它第三方APP在用户空间运行

划分的原因是保护系统（你用支付宝支付物品，这种密码什么的，如果没有这种保护，360岂不是随便就能获取到这个信息）

CPU运行安全等级：ring0、ring1、ring2、ring3
ring0就是内核态，最高级别
一般我们的app是运行在ring3，就是用户态中

linux只有ring0、ring3

线程还是操作系统管理（创建）的，而不是JVM
pthread，系统的指令，运行这个创建线程


所以一个进程或者一个线程，不仅仅只有一个堆栈，而是有两个，一个在用户空间，一个在内核空间

因为JVM需要创建线程的时候，那个创建线程的CPU线程（我都不知道在说什么）需要陷入到内核态里面，所有就有两个，而如果需要删除这个线程或者进程，还是要先陷入内核态，当一个线程的状态陷入内核空间的时候，他就不再有用户空间了

CPU调度的基本单位线程，划分为:
1、内核线程模型（KLT）
2、用户线程模型（ULT）
所以JAVA是KLT调度方式


CPU采用时间片轮转的方式执行的（线程的上下文切换）
当一个线程时间片用完之后，就会被保存在内存（TSS，task state segment程序任务状态段）中，然后CPU去执行另一个线程，这就是线程切换的原因


JVM是栈指令集架构，一个简单地加法，需要把变量放到局部变量表中，然后又把数字拿出来，然后再加，复杂的很哩

而寄存器指令级架构，就是直接加，然后得出返回结果